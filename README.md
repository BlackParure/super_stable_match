# Super Stable Matching with User Interface

This is a project which uses Python to realize algorithm for Super Stable Matching Problem, and display the result by Flask and NetworkX.

Here is the example,

![Result_Example](/Result_Example.png)

## Getting Start

Required packages can be installed by following codes,

```bash
pip install -r requirements.txt
```



## Starting Flask Server

You can use 

```bash
python super_stable_matching.py
```

to simply run the super stable algorithm which is mention by [Wikipedia](https://en.wikipedia.org/wiki/Stable_marriage_with_indifference) and [Robert W.Irving](https://www.sciencedirect.com/science/article/pii/0166218X9200179P?via%3Dihub).

To completely start it with an UI should use

``` bash
python graph.py
```

Then the local server will run on http://localhost:5000/superStableMatching.



## General Idea

### Super Stable Matching Part

For this part, I capsule the instance generating algorithm and super stable matching algorithm separately so that we can use these functions easier in future work, especially for front-end page design.

The most important task is to decide the structure of preference information. In this work, I use a class `Person` for man and women individual, which includes their name and preference. 

```python
class Person:
  def __init__(self, name, preference):
    self.name = name
    self.preference = preference
```

The preference are stored in format of list, which contains smaller list for tie preference, for example,

```
{'Man_1': [['Woman_3'], ['Woman_2'], ['Woman_4'], ['Woman_1']], 
 'Man_2': [['Woman_3'], ['Woman_1'], ['Woman_4', 'Woman_2']], 
 'Man_3': [['Woman_3'], ['Woman_1'], ['Woman_4'], ['Woman_2']], 
 'Man_4': [['Woman_4'], ['Woman_1'], ['Woman_3'], ['Woman_2']]}
```

Tie preference are generated by a `density_threshold`, we firstly shuffle all people with opposite gender. Then generate a uniform random number between 0 to 1, if it higher than density threshold the next person in the shuffle list will be in a tie with the former one.

```python
if random.uniform(0,1) <= self.man_tie_density:
	Append to the last priority list in the whole preference list
else:
	Directly append to the preference list
```

Also, we provide `pref_list_length_lb` and  `pref_list_length_ub=4` for possible preference length setting.

On the other hand, we generate dictionaries `man_index` and `woman_index` with `key = person().name` and `value = Person()`. As we record their preference only by other's name, will have to traverse each instance every time we need their name. These two dictionary will be greatly helpful for future name-instance conversion. 

The we use the general idea for this problem, 

<ol>
 <li>We try to make engagement by preference of man m, which the top selection is w. </li>
 <li>Then we disengage all man m' whose priority are lower than m in w's preference and delete them from preference list. </li>
 <li>For all women with multiple engagements, we disengage all relations and delete the man with least priority.</li>
 <li>Do this in loop until all man is engaged or one's preference is empty.</li>
</ol>

After that we will get a result contains pairs like that,

```python
[['Man_1', 'Woman_3'], ['Man_2', 'Woman_1'], ['Man_3', 'Woman_4'], ['Man_4', 'Woman_2']]
```



### Flask and NetworkX

As we get the final result for the super stable algorithm, we use this pair list to generate a graph with the help of networkX,

```python
G.add_node(index, name=pa, man=pa, woman=pb, bipartite=0)
G.add_node(index+1, name=pb, man=pa, woman=pb, bipartite=1)
G.add_edge(index, index+1)
```

 The first parameter is node index, following by three attributes `name`, `man` and `women`. Then we convert it to a dictionary and save it as d3_format by

```python
graph_dict = graph_to_dict(G)
d3_graph_dict = d3_format(graph_dict)
jsonify(dict(data=d3_graph_dict))
```

This will be returned as a json file via flask to `route('/data')`, so that we can use `render_template("superStableMatching.html")` to get it fro data and render the graph.



### Html and JavaScript Part

In HTML, we only need include Tippy for showing text, d3 for data and our own js file,

```html
<!-- Tippy -->  
<script src="https://unpkg.com/tippy.js@2.5.2/dist/tippy.all.min.js"></script>
<!-- d3 lib -->
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="/static/js/superStableMatching.js"></script>
```

Then, in `superStableMatching.js`, we applied highlight function by 

```javascript
function setNodeEvents() {
    nodeSelection
        .on("mouseover", onNodeMouseOver)
        .on("mousedown", onNodeMouseDown)
        .on("mouseout", onNodeMouseOut);
}
function onNodeMouseDown(node) {
    d3.event.stopPropagation();
    focusNode = node;
    setFocus(node);
    if (highlightNode === null) {
        setHighlight(node);
    }
}

function onNodeMouseOut(node) {
    exitHighlight();
}

function onNodeMouseUp() {
    if (focusNode !== null) {
        focusNode = null;
        if (highlightTrans < 1) {
            circleSelection.style("opacity", 1);
            textSelection.style("opacity", 1);
            linkSelection.style("opacity", 1);
        }
    }
    if (highlightNode === null) {
        exitHighlight();
    }
}
```

For attribute text, we use tippy and svg `svg g g path` to set it on the node ,

```javascript
function onNodeMouseOver(node) {
    setHighlight(node);
    tippy('svg g g path', {
        animation: 'scale',
        arrow: true,
        arrowType: 'round',
        delay: 100,
        duration: 500,
        size: 'normal',
        sticky: true
    });
}
```

So that we we hover our mouse on a node it will display the attribute.(Note: when there is no vaild super stable matching there will be no graphic, just click the button `Generate Random New Example` to get a new output)
