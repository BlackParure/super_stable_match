# -*- coding: utf-8 -*-
"""Super_Stable_matching.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QK8RhmfcKHoqOpwnipPqQT14EmleYjd8
"""
import random
import math
import json
from flask import Flask, render_template, jsonify
import networkx as nx
from networkx.algorithms import bipartite
from os import path
from networkx.readwrite import json_graph
# from graph import random_graph, random_connected_graph, graph_to_dict, d3_format, export_json




class SSM:
    def __init__(self, mans, womans, pref_list_length_lb=4, pref_list_length_ub=4, man_tie_density=0.1, woman_tie_density=0.1):

        self.mans = mans   # list of men
        self.womans = womans  # list of women  
        self.lb = pref_list_length_lb  # lower bound of the student's preference list
        self.ub = pref_list_length_ub  # int(sys.argv[3])  # upper bound of the student's preference list
        self.man_tie_density = man_tie_density
        self.woman_tie_density = woman_tie_density
        
        self.man_prefer = {}
        self.woman_prefer = {}


    def preference_generator_with_ties(self):            
        # -----------------------------------------------------------------------------------------------------------------------------------------
        # ---------------------------------------        ====== STUDENTS =======                    -----------------------------------------------
        # here we decide the length l of each student's preference list
        # we also choose l projects at random, which forms the student's preference list
        # -----------------------------------------------------------------------------------------------------------------------------------------
        self.man_prefer = {str(i): [] for i in self.mans} 
        for m_key in self.man_prefer:
            length = random.randint(self.lb, self.ub)  # randomly decide the length of each student's preference list
            #  based on the woman list, we provide man_preference at random
            wm_copy = self.womans[:]            
            random.shuffle(wm_copy)
            man_prefer_wo_ties = wm_copy[0:length]
            self.man_prefer[m_key].append([man_prefer_wo_ties[0]])
            for mp in range(1,len(man_prefer_wo_ties)):
              if random.uniform(0,1) <= self.man_tie_density:
                self.man_prefer[m_key][-1].append(man_prefer_wo_ties[mp])
              else:
                self.man_prefer[m_key].append([man_prefer_wo_ties[mp]])

        self.woman_prefer = {str(i): [] for i in self.womans} 
        for wm_key in self.woman_prefer:
            length = random.randint(self.lb, self.ub)  # randomly decide the length of each student's preference list
            #  based on the woman list, we provide man_preference at random
            m_copy = self.mans[:]            
            random.shuffle(m_copy)
            woman_prefer_wo_ties = m_copy[0:length]
            self.woman_prefer[wm_key].append([woman_prefer_wo_ties[0]])
            for wmp in range(1,len(woman_prefer_wo_ties)):
              if random.uniform(0,1) <= self.woman_tie_density:
                self.woman_prefer[wm_key][-1].append(woman_prefer_wo_ties[wmp])
              else:
                self.woman_prefer[wm_key].append([woman_prefer_wo_ties[wmp]])

    def generate_stable_matching(self):
      pass



# instance generate and matching algorithm are perfectly capsuled
# it is hard to find a specific object which has matched with a certain people so we use two dict to maintain existing matching

class Person:
  def __init__(self, name, preference):
    self.name = name
    self.preference = preference

def analyze_input(man_instance_input, woman_instance_input):
  man, woman = [], []
  man_index, woman_index = {}, {}
  man_num, woman_num = len(man_instance_input), len(woman_instance_input)
  for mk in man_instance_input:
    mi = Person(mk, man_instance_input[mk])
    man.append(mi)
    man_index[mk] = mi
  for wmk in woman_instance_input:
    wmi = Person(wmk, woman_instance_input[wmk])
    woman.append(wmi)
    woman_index[wmk] = wmi 
  return [man, woman, man_index, woman_index]

def delete_pairs(person_instance, target):
  target_name = target.name
  for w in person_instance.preference:
    if target_name in w:
      if len(w)==1:
        person_instance.preference.remove(w)
      else:
        w.remove(target_name)
      break
  return person_instance

def single_check(man, man_matching):
  item = man_matching[man]
  if len(item)>0:
    return False
  return True

def generate_stable_matching(man_list, woman_list, man_index, woman_index):
  # man_index, woman_index will be used as a name list to find
  # the correspoding index of a specific person ([Peter, Alan, ...])
  res = []
  man_num, woman_num = len(man_list), len(woman_list)
  # Recording current matching detail (Peter->Mary&Rose, ...)
  man_matching = {i: [] for i in man_list} 
  woman_matching = {i: [] for i in woman_list}
  # This is a boolean list to check the match result of each person ([False, False, True, ...])
  man_isMatched, woman_isMatched = [False]* man_num, [False]* woman_num

  while (False in man_isMatched):
    print("Loop Start")
    m = man_list[man_isMatched.index(False)]
    for w in m.preference[0]:
      wi = woman_index[w]
      man_matching[m].append(wi)
      woman_matching[wi].append(m)

      man_isMatched[man_list.index(m)] = 1
      woman_isMatched[woman_list.index(wi)] = 1
      # travelse all the m' for w
      lower = False
      for m_name_group in wi.preference:
        if lower:
          for mpn in m_name_group:
            mp = man_index[mpn]
            if mp in woman_matching[wi]:
              woman_matching[wi].remove(mp)
              man_matching[mp].remove(wi)
            # lack of sinle check
            if single_check(mp, man_matching):
              man_isMatched[man_list.index(mp)] = 0
            print("Delete for successor", mp.name, wi.name, mp.preference, wi.preference)
            mp = delete_pairs(mp, wi)
            wi = delete_pairs(wi, mp)

            print("Complete Deletion for successor", mp.name, wi.name, mp.preference, wi.preference)
            if mp.preference == []:
              return None
        if m.name in m_name_group:
          lower = True
    for w in woman_matching:
      
      if len(woman_matching[w])>1:
        print("Multi-engaged woman", w.name, woman_matching[w], w.preference)
        for mp in woman_matching[w]:
          woman_matching[w].remove(mp)
          man_matching[mp].remove(w)
          if single_check(mp, man_matching):
            man_isMatched[man_list.index(mp)] = 0
        woman_isMatched[woman_list.index(w)] = 0
        print("Prepare to delete pair for least prefer", w.preference)
        if w.preference == []:
            return None
        for ml in w.preference[-1]:
          mli = man_index[ml]
          mli = delete_pairs(mli, w)
          w = delete_pairs(w, mli)
          if mp.preference == []:
            return None
  for i in man_matching:
    res.append([i.name, man_matching[i][0].name])
  return res

def main_session():
  person_number = 4
  ml = ["Man_"+str(i) for i in range(1, person_number+1)]
  wl = ["Woman_"+str(i) for i in range(1, person_number+1)]
  print("Input Person List is: ")
  print("Man: ", ml)
  print("Woman: ", wl)
  SSM_instance = SSM(ml,wl)
  SSM_instance.preference_generator_with_ties()
  print(SSM_instance.man_prefer, SSM_instance.woman_prefer)
  print("Instance Genereted Successfully") 
  [man, woman, man_index, woman_index] = analyze_input(SSM_instance.man_prefer, SSM_instance.woman_prefer)
  print(man, woman, man_index, woman_index)
  res = generate_stable_matching(man, woman, man_index, woman_index)
  return res  
if __name__ == "__main__": 
  # SSM_instance.man_prefer = {'a': [['e', 'd'], ['f']], 'b': [['d', 'f'], ['e']], 'c': [['d', 'f', 'e']]}
  # SSM_instance.woman_prefer = {'d': [['a'], ['b', 'c']], 'e': [['b'], ['a', 'c']], 'f': [['c'], ['a'], ['b']]}
  res = main_session()


  print(res)
